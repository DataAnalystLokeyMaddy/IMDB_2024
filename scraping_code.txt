# ---> Here we start the project with Scrapping 


from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import pandas as pd
import time

# Setup Chrome
service = Service("chromedriver.exe")  # path to your chromedriver
driver = webdriver.Chrome(service=service)

# Extended genres list (will easily cross 1000 movies total across all CSVs)
genres = [
    "horror", "action", "crime", "history", "drama", "thriller", 
    "comedy", "romance", "sci-fi", "animation", "adventure", 
    "fantasy", "mystery", "family", "war", "sport", "western", 
    "musical", "documentary", "biography"
]

# IMDb base search URL (50 per page, pagination will fetch the rest)
base_url = "https://www.imdb.com/search/title/?title_type=feature&release_date=2024-01-01,2024-12-31&genres={}&count=50"

for genre in genres:
    url = base_url.format(genre)
    driver.get(url)
    time.sleep(2)

    movie_names = []
    movie_ratings = []
    movie_votes = []
    movie_durations = []
    movie_genres = []

    while True:
        # wait for movies to load
        WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.CLASS_NAME, "ipc-metadata-list-summary-item"))
        )

        movies = driver.find_elements(By.CLASS_NAME, "ipc-metadata-list-summary-item")

        for movie in movies:
            try:
                title = movie.find_element(By.TAG_NAME, "h3").text
            except:
                title = "N/A"

            try:
                genre_text = movie.find_element(By.CLASS_NAME, "ipc-chip__text").text
            except:
                genre_text = genre.capitalize()

            try:
                rating = movie.find_element(By.CSS_SELECTOR, "span.ipc-rating-star--rating").text
            except:
                rating = "N/A"

            try:
                votes = movie.find_element(By.CSS_SELECTOR, "span.ipc-rating-star--voteCount").text
            except:
                votes = "N/A"

            try:
                duration = "N/A"
                metadata_items = movie.find_elements(By.CSS_SELECTOR, "span")
                for item in metadata_items:
                    text = item.text.strip()
                    if "h" in text or "m" in text:  # matches "2h 15m", "45m"
                        duration = text
                        break
            except:
                duration = "N/A"
            

            movie_names.append(title)
            movie_genres.append(genre_text)
            movie_ratings.append(rating)
            movie_votes.append(votes)
            movie_durations.append(duration)

        # check for next page button
        try:
            next_btn = driver.find_element(By.XPATH, "//a[contains(@class,'ipc-pagination-next')]")
            if "disabled" in next_btn.get_attribute("class"):
                break
            else:
                next_btn.click()
                time.sleep(2)
        except:
            break

    # save per-genre
    df = pd.DataFrame({
        "MovieName": movie_names,
        "Genre": movie_genres,
        "Rating": movie_ratings,
        "Votes": movie_votes,
        "Duration": movie_durations
    })

    df.to_csv(f"{genre.capitalize()}_Movies_2024.csv", index=False, encoding="utf-8-sig")
    print(f"Saved {len(df)} movies for {genre.capitalize()}")

driver.quit()
